package repository;

import dto.*;
import entity.Carrera;
import entity.CarreraEstudiante;
import entity.Estudiante;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.persistence.*;
import java.math.BigInteger;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

public class CarreraRepositoryImpl implements CarreraRepository {

    private final EntityManager em;
    private static final Logger logger = LoggerFactory.getLogger(CarreraRepositoryImpl.class);

    public CarreraRepositoryImpl () {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Integrador2");
        this.em = emf.createEntityManager();
    }

    /**
        Carrera has an id autogenerated, so maybe we would never use this method
     */
    @Override
    public Carrera findById ( int idCarrera ) {
        String query = "SELECT c FROM Carrera c WHERE c.id_carrera = :id";
        Query q = this.em.createQuery( query );
        q.setParameter( "id", idCarrera );
        try {
            return ( Carrera ) q.getSingleResult();
        } catch(NoResultException e) {
            logger.info("Didn't find result for idCarrera = " + idCarrera);
            return null;
        }
    }

    /**
     * Carrera has a unique name, so this method is better than the one above
     * @param name carrer to
     * @return carrera, if exists any with that name, else it will throw an exception
     */
    @Override
    public Carrera findByName( String name ) {
        String query = "SELECT c FROM Carrera c WHERE c.nombre = :nombre";
        Query q = this.em.createQuery( query );
        q.setParameter( "nombre", name );
        try {
            return ( Carrera ) q.getSingleResult();
        } catch(NoResultException e) {
            logger.info("Didn't find result for name = " + name);
            return null;
        }
    }

    @Override
    public void save( Carrera carrera ) {
        Carrera c = this.findByName( carrera.getNombre() );
        this.em.getTransaction().begin();
        if ( c != null )
            this.em.merge( carrera );
        else
            this.em.persist( carrera );
        em.getTransaction().commit();
    }

    @Override
    public List<Carrera> findAll() {
        String jpql = "SELECT c FROM Carrera c";
        Query q = this.em.createQuery( jpql );
        return (List<Carrera>) q.getResultList();
    }

    @Override
    public List<CarreraDto> findAllByInscriptosOrderByCount() {
        String sql = """
                SELECT new CarreraDto( c.id_carrera, c.nombre, count(*) )
                FROM Carrera c 
                JOIN CarreraEstudiante ce 
                ON c.id_carrera = ce.carrera.id_carrera
                GROUP BY c.id_carrera, c.nombre
                ORDER BY 3 DESC
                """.trim();
        Query q = this.em.createQuery(sql, CarreraDto.class);
        return (List<CarreraDto>) q.getResultList();
    }

    @Override
    public void addStudent (Carrera c, Estudiante e, LocalDate fechaIngreso, LocalDate fechaEgreso ) {
        c.addStudent(new CarreraEstudiante(c, e, fechaIngreso, fechaEgreso));
    }

    @Override
    public void removeStudent ( Carrera c, CarreraEstudiante carreraEstudiante ) {
        c.removeStudent( carreraEstudiante );
    }

    /**
     * @return a report list
     */
    @Override
    public List<CarreraReportDto> report() {
        String query = """ 
                SELECT c.id_carrera, c.nombre ,
                        year(fechaIngreso) as añoIngreso, year(fechaEgreso) as añoEgreso,
                        count(idEstudiante) OVER (wIngresos) as ingresos,
                        count(idEstudiante) OVER (PARTITION BY c.id_carrera,year(fechaEgreso)) as egresos  
                    FROM carrera c join carrera_estudiante  ce on c.id_carrera = ce.idCarrera
                WINDOW wIngresos AS (PARTITION BY c.id_carrera,year(fechaIngreso))
                ORDER BY c.nombre, year(fechaIngreso), year(fechaEgreso)  """.trim();
        Query q = this.em.createNativeQuery( query);
        List<Object[]> report = q.getResultList();
        return this.mapper( report );
    }

    private ArrayList<CarreraReportDto> mapper(List<Object[]> report) {
        ArrayList<CarreraReportDto> carreraReport = new ArrayList<>();
        for ( Object[] o : report ) {
            carreraReport.add( new CarreraReportDto( (int)o[0], (String) o[1],
                        (int) o[2], (int) o[3],
                    (BigInteger) o[4], (BigInteger) o[5] ) );
        }
        return carreraReport;
    }

}
